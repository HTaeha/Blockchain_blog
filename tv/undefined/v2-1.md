---
description: Uniswap V2ì˜ ì½”ë“œë¥¼ ë¶„ì„í•´ë³´ì!
---

# V2 ì½”ë“œ ë¶„ì„

#### uniswap-v2-core

[GitHub - Uniswap/v2-core: ğŸ› Core smart contracts of Uniswap V2](https://github.com/Uniswap/v2-core)

contrancts í´ë”ì— interfaces, libraries, test í´ë”ëŠ” ë³¼ í•„ìš” ì—†ë‹¤. ë°‘ì— 3ê°€ì§€ solidity ì½”ë“œë§Œ ë³´ë©´ ë˜ëŠ”ë° UniswapV2ERC20.sol íŒŒì¼ì€ UNI í† í°ì— ëŒ€í•œ ê²ƒì´ë‹¤. ê·¸ë˜ì„œ UniswapV2Factory.sol, UniswapV2Pair.sol 2ê°€ì§€ íŒŒì¼ë§Œ ë³´ë©´ ëœë‹¤.

## UniswapV2Factory.sol

ìƒˆë¡œìš´ pairë¥¼ ê±°ë˜í•˜ëŠ” ì»¨íŠ¸ë™íŠ¸ë¥¼ ìƒì„±í•´ë‚´ê³  ê´€ë¦¬í•˜ëŠ” ê²Œì´íŠ¸ì›¨ì´.

### createPair

```solidity
function createPair(address tokenA, address tokenB) external returns (address pair) {
    require(tokenA != tokenB, 'UniswapV2: IDENTICAL_ADDRESSES');
    (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
    require(token0 != address(0), 'UniswapV2: ZERO_ADDRESS');
    require(getPair[token0][token1] == address(0), 'UniswapV2: PAIR_EXISTS'); // single check is sufficient
    bytes memory bytecode = type(UniswapV2Pair).creationCode;
    bytes32 salt = keccak256(abi.encodePacked(token0, token1));
    assembly {
        pair := create2(0, add(bytecode, 32), mload(bytecode), salt)
    }
    IUniswapV2Pair(pair).initialize(token0, token1);
    getPair[token0][token1] = pair;
    getPair[token1][token0] = pair; // populate mapping in the reverse direction
    allPairs.push(pair);
    emit PairCreated(token0, token1, pair, allPairs.length);
}
```

ìƒˆë¡œìš´ pair ì»¨íŠ¸ë™íŠ¸ë¥¼ ë§Œë“¤ì–´ë‚´ëŠ” í•¨ìˆ˜.

tokenAì™€ tokenBì˜ ì£¼ì†Œë¥¼ argumentë¡œ ë°›ê³  ìˆë‹¤.

line 1

* ë‘ í† í°ì˜ ì£¼ì†Œê°€ ê°™ìœ¼ë©´ ì•ˆ ëœë‹¤.

line 2

* ë‘ í† í° ì£¼ì†Œë¥¼ ë¹„êµí•´ì„œ Aê°€ í¬ë©´ B-A pairë¥¼ ë§Œë“¤ê³  Bê°€ í¬ë©´ A-B pairë¥¼ ë§Œë“ ë‹¤.
* A-B pairì™€ B-A pairëŠ” ê°™ì€ ê²ƒì¸ë° ì´ê²ƒì„ í† í° ì£¼ì†Œì˜ í¬ê¸°ë¡œ ë¹„êµí•˜ì—¬ ì •ì˜í•œ ê²ƒì´ë‹¤.

line 3

* token0ì˜ ì£¼ì†Œê°€ 0ì¸ì§€ ê²€ì‚¬í•œë‹¤.
* ì£¼ì†Œê°€ 0ì¸ ì»¨íŠ¸ë™íŠ¸ëŠ” ì—†ë‹¤.
* token1ì€ token0ë³´ë‹¤ í¬ê¸° ë•Œë¬¸ì— token1ì€ ê²€ì‚¬ë¥¼ í•˜ì§€ ì•Šì•„ë„ ëœë‹¤.

line 4

* ë‘ í† í° í˜ì–´ì— í•´ë‹¹í•˜ëŠ” ì»¨íŠ¸ë™íŠ¸ê°€ ì´ë¯¸ ìˆëŠ”ì§€ ê²€ì‚¬í•œë‹¤.
* factoryê°€ í† í° í˜ì–´ë¥¼ ê´€ë¦¬í•˜ëŠ” ìë£Œêµ¬ì¡°ë¥¼ ë‹´ê³  ìˆëŠ” ë³€ìˆ˜ ì´ë¦„ì´ getPairì´ë‹¤.
* ë§Œì•½ ì¡´ì¬í•œë‹¤ë©´ revertì‹œí‚¨ë‹¤. ì´ë¯¸ ì¡´ì¬í•˜ëŠ” í† í° í˜ì–´ë¥¼ ë˜ ë§Œë“¤ë©´ ì•ˆ ë˜ê¸° ë•Œë¬¸ì´ë‹¤.

line 5

* UniswapV2Pairì˜ tokenPair ì»¨íŠ¸ë™íŠ¸ ì½”ë“œë¥¼ ë°”ì´íŠ¸ì½”ë“œë¡œ ê°€ì ¸ì˜¨ë‹¤.

line 6

* saltë¥¼ í•˜ë‚˜ ë§Œë“ ë‹¤.
* token0, token1ì˜ abië¥¼ keccak256ì´ë¼ê³  í•˜ëŠ” hash í•¨ìˆ˜ë¥¼ ëŒë ¤ì„œ ë§Œë“¤ì–´ë‚¸ë‹¤.

line 7-9

* create2í•¨ìˆ˜ë¥¼ ê°€ì§€ê³  pair ì»¨íŠ¸ë™íŠ¸ë¥¼ ë§Œë“ ë‹¤.
* ì–´ì…ˆë¸”ë¦¬ì–´ë¡œ ì„ ì–¸ì´ ë˜ì–´ ìˆë‹¤.

line 10

* token0ê³¼ token1ì„ ì´ˆê¸°í™” ì‹œì¼œì¤€ë‹¤.
* ì´ì œë¶€í„° ì´ pairëŠ” token0ì™€ token1ì„ ê±°ë˜í•  ìˆ˜ ìˆëŠ” í’€ì´ ëœë‹¤.

line 11-12

* getPairëŠ” token exchange contractì˜ ì£¼ì†Œë¥¼ ë‹´ê³  ìˆëŠ” ìë£Œêµ¬ì¡°ì´ë‹¤.
* token0, token1ì— í•´ë‹¹í•˜ëŠ” ìš”ì†Œì— pairë¥¼ ë„£ì–´ì¤€ë‹¤.
* ì•ˆì •ì„±ì„ ìœ„í•´ ëª¨ë“  ì¡°í•©ì— ëŒ€í•´ ë‹¤ ë„£ì–´ì£¼ëŠ” ê²ƒ ê°™ë‹¤.

line 13

* allPairsì— ìƒˆë¡œ ìƒì„±í•œ pairë¥¼ í‘¸ì‹œí•´ì¤€ë‹¤.

line 14

* ìƒˆë¡œ pairë¥¼ ë§Œë“¤ì—ˆë‹¤ëŠ” ë¡œê·¸ë¥¼ ë‚¨ê²¨ì¤€ë‹¤.

V2ì—ì„œ ìƒˆë¡œ ìƒê¸´ ê²ƒì´ fee ì¤‘ì— 0.05%ë¥¼ ê°€ì ¸ì˜¤ëŠ” ê²ƒì´ë‹¤. ê·¸ê²ƒì„ ìœ„í•´ì„œ feeTo ë¼ê³  í•˜ëŠ” address ë³€ìˆ˜ë¥¼ ë„£ì–´ë†¨ë‹¤. V2 ë°±ì„œì—ì„œ ë´¤ë˜ ê³µì‹ì— ì˜í•´ì„œ ì´ ë³€ìˆ˜ì—ê²Œ í† í° ì»¨íŠ¸ë™íŠ¸ì—ì„œ ê±°ë˜ë˜ëŠ” ìˆ˜ìˆ˜ë£Œì˜ ì¼ë¶€ê°€ ê°€ê²Œ ëœë‹¤.

## UniswapV2Pair.sol

ì‹¤ì œë¡œ ë‘ í† í°ì„ ê±°ë˜í•˜ëŠ” í’€ì´ì ê±°ë˜ì†Œ.

ìœ„ì˜ UniswapV2Factory.sol ì—ì„œ ìƒì„±í•œ V2Pairë¥¼ ì•Œì•„ë³´ì.

### constructor

```solidity
constructor() public {
    factory = msg.sender;
}
```

constructorì— factory ì£¼ì†Œë¥¼ ë„£ì–´ì¤€ë‹¤.

msg.senderëŠ” íŠ¸ëœì­ì…˜ì„ ë³´ë‚¸ addressë¥¼ ë‚˜íƒ€ë‚¸ë‹¤.

factoryê°€ v2pairë¥¼ ìƒì„±í–ˆê¸° ë•Œë¬¸ì— msg.senderê°€ factory ì£¼ì†Œë¥¼ ë°›ì•„ì˜¨ë‹¤.

### initialize

```solidity
// called once by the factory at time of deployment
function initialize(address _token0, address _token1) external {
    require(msg.sender == factory, 'UniswapV2: FORBIDDEN'); // sufficient check
    token0 = _token0;
    token1 = _token1;
}
```

Facotryì—ì„œ í˜¸ì¶œí–ˆë‹¤.

token0ì™€ token1ì— ê°ê°ì˜ argumentë¥¼ ëŒ€ì…í•´ì¤€ë‹¤.

### \_update

```solidity
// update reserves and, on the first call per block, price accumulators
function _update(uint balance0, uint balance1, uint112 _reserve0, uint112 _reserve1) private {
    require(balance0 <= uint112(-1) && balance1 <= uint112(-1), 'UniswapV2: OVERFLOW');
    uint32 blockTimestamp = uint32(block.timestamp % 2**32);
    uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired
    if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {
        // * never overflows, and + overflow is desired
        price0CumulativeLast += uint(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * timeElapsed;
        price1CumulativeLast += uint(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * timeElapsed;
    }
    reserve0 = uint112(balance0);
    reserve1 = uint112(balance1);
    blockTimestampLast = blockTimestamp;
    emit Sync(reserve0, reserve1);
}
```

ì»¨íŠ¸ë™íŠ¸ëŠ” ìê¸°ê°€ ì–¼ë§ˆë¥¼ ë“¤ê³  ìˆëŠ”ì§€ ê³„ì†í•´ì„œ ì¶”ì í•œë‹¤. í•˜ì§€ë§Œ ê·¸ ì¶”ì ì´ í•­ìƒ ë§ì§€ëŠ” ì•Šë‹¤.

ì‹¤ì œ ì”ê³ ëŠ” token0ì™€ token1 ì»¨íŠ¸ë™íŠ¸ì— ìˆê³  ê·¸ ì”ê³ ì— ëŒ€í•œ ì •ë³´ëŠ” ì´ ì»¨íŠ¸ë™íŠ¸ì— ê°€ì•¼ ë³¼ ìˆ˜ ìˆë‹¤. ë‚´ê°€ ì§€ê¸ˆ ê¸°ë¡í•˜ê³  ìˆëŠ” í† í°ì˜ ìˆ˜ëŸ‰ë³´ë‹¤ í† í° ì»¨íŠ¸ë™íŠ¸ì— ìˆëŠ” ìˆ˜ëŸ‰ì´ ë” ë§ë‹¤ë©´ ë‚´ê°€ ëˆì„ ë°›ì•˜ë‹¤ëŠ” ê²ƒì„ ì•Œ ìˆ˜ ìˆë‹¤. (ì´ í† í° í’€ì— í† í°ì´ ë“¤ì–´ì™”ë‹¤ëŠ” ê²ƒì„ ì•Œ ìˆ˜ ìˆë‹¤. - ì…ê¸ˆ)

ê·¸ ì •ë³´ë¥¼ ë³´ê³  ì—…ë°ì´íŠ¸ í•´ì£¼ëŠ” ê²ƒì´ \_update í•¨ìˆ˜ì´ë‹¤.

line 2 - 8

* blockTimestamp, timeElapsed, price0CumulativeLast, price1CumulativeLast ë³€ìˆ˜ë“¤ì„ ëª¨ì¢…ì˜ ë¡œì§ìœ¼ë¡œ ë°”ê¾¸ì–´ì£¼ê³  ìˆë‹¤.
* ì´ê²ƒì´ Uniswapì„ price oracleë¡œ ì“°ê¸° ìœ„í•œ ë¡œì§ì´ë‹¤.
* ê°ê°ì˜ priceë“¤ì´ ìœ ì§€ëœ ì‹œê°„ì˜ ê°€ì¤‘ì¹˜ë§Œí¼ ë”í•´ì„œ í‰ê· ì„ ë‚¸ í›„ í˜„ì¬ ê°€ê²©ì„ ê²°ì •í•œë‹¤.
* price0CumulativeLast, price1CumulativeLastê°€ publicìœ¼ë¡œ ì„ ì–¸ë˜ì–´ ìˆê¸° ë•Œë¬¸ì— Uniswapì„ price oracleë¡œ ì‚¬ìš©í•˜ê³  ì‹¶ë‹¤ë©´ ì € ë‘ ë³€ìˆ˜ë¥¼ ë³´ë©´ ëœë‹¤.

### \_mintfee

```solidity
// if fee is on, mint liquidity equivalent to 1/6th of the growth in sqrt(k)
function _mintFee(uint112 _reserve0, uint112 _reserve1) private returns (bool feeOn) {
    address feeTo = IUniswapV2Factory(factory).feeTo();
    feeOn = feeTo != address(0);
    uint _kLast = kLast; // gas savings
    if (feeOn) {
        if (_kLast != 0) {
            uint rootK = Math.sqrt(uint(_reserve0).mul(_reserve1));
            uint rootKLast = Math.sqrt(_kLast);
            if (rootK > rootKLast) {
                uint numerator = totalSupply.mul(rootK.sub(rootKLast));
                uint denominator = rootK.mul(5).add(rootKLast);
                uint liquidity = numerator / denominator;
                if (liquidity > 0) _mint(feeTo, liquidity);
            }
        }
    } else if (_kLast != 0) {
        kLast = 0;
    }
}
```

í”„ë¡œí† ì½œ feeë¥¼ ê³„ì‚°í•˜ëŠ” í•¨ìˆ˜ì´ë‹¤.

ì•„ë˜ í•¨ìˆ˜ì—ì„œ Ï•ë¥¼ 1/6ì„ ëŒ€ì…í•œ ê³µì‹ì´ë‹¤.

![](<../../.gitbook/assets/image (33).png>)

### mint

```solidity
// this low-level function should be called from a contract which performs important safety checks
function mint(address to) external lock returns (uint liquidity) {
    (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings
    uint balance0 = IERC20(token0).balanceOf(address(this));
    uint balance1 = IERC20(token1).balanceOf(address(this));
    uint amount0 = balance0.sub(_reserve0);
    uint amount1 = balance1.sub(_reserve1);

    bool feeOn = _mintFee(_reserve0, _reserve1);
    uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee
    if (_totalSupply == 0) {
        liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);
       _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens
    } else {
        liquidity = Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1);
    }
    require(liquidity > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_MINTED');
    _mint(to, liquidity);

    _update(balance0, balance1, _reserve0, _reserve1);
    if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date
    emit Mint(msg.sender, amount0, amount1);
}
```

LP í† í°ì„ ë§Œë“¤ì–´ë‚´ëŠ” í•¨ìˆ˜ì´ë‹¤.

pair contractì—ì„œ ê¸°ë¡í•˜ê³  ìˆëŠ” ìì‚°ì˜ ì–‘ê³¼ í•´ë‹¹ token contractì—ì„œ ê¸°ë¡í•˜ê³  ìˆëŠ” ìì‚°ì˜ ì–‘ì´ ë‹¤ë¥¼ ìˆ˜ ìˆë‹¤.

ë§Œì•½ í† í° ì»¨íŠ¸ë™íŠ¸ì— ìˆëŠ” ë‚´ ìì‚°ì˜ ì–‘ì´ ë” ë§ìœ¼ë©´ mintì‹œì¼œì¤˜ì•¼ í•œë‹¤. ë°˜ëŒ€ë¡œ ë” ì ë‹¤ë©´ burnì„ ì‹œì¼œì¤˜ì•¼ í•œë‹¤.

line 1

* ë‚´ pair contractì—ì„œ ê¸°ë¡í•˜ê³  ìˆëŠ” ì”ê³ 

line 2 - 3

* token0, token1 ì»¨íŠ¸ë™íŠ¸ì—ì„œ ì”ê³ ë¥¼ ë°›ì•„ì˜´.

line 4 - 5

* ë°›ì•„ì˜¨ ì”ê³ ì—ì„œ ê¸°ë¡í•˜ê³  ìˆëŠ” ì”ê³ ë¥¼ ë¹¼ì„œ ë‚´ê°€ ë°›ì€ ì–‘(amount)ë¥¼ ê³„ì‚°í•œë‹¤.

line 7

* ìˆ˜ìˆ˜ë£Œë¥¼ ê³„ì‚°í•œë‹¤.

line 8 - 14

* totalSupplyê°€ 0ì´ë¼ëŠ” ê²ƒì€ ì²˜ìŒ ì´ ì»¨íŠ¸ë™íŠ¸ì— pairë¥¼ ë„£ëŠ” ì‚¬ëŒì´ë¼ëŠ” ê²ƒì´ë‹¤. ì´ë•Œì—ëŠ” LP shareì˜ ìµœì†Œ ë‹¨ìœ„ ì¦‰ 1LP í† í°ì˜ ì²œë°°ì— í•´ë‹¹í•˜ëŠ” ëˆì´ burnëœë‹¤. address 0 ì—ê²Œ ìƒì„±í•˜ì§€ë§Œ address 0 ëŠ” ì¡´ì¬í•˜ì§€ ì•Šê¸° ë•Œë¬¸ì— ì´ ëˆì€ ê·¸ëƒ¥ ë¬¶ì´ê²Œ ëœë‹¤.(burn) ì´ì „ ë°±ì„œì—ì„œ ë´¤ë˜ ê³µì‹ì— ë”°ë¼ liquidityê°€ ì •í•´ì§„ë‹¤.
* totalSupplyê°€ 0ì´ ì•„ë‹ˆë©´ ì¸í”Œë ˆì´ì…˜ì„ ì‹œí‚¤ê²Œ ëœë‹¤. ì´ì „ ë°±ì„œì—ì„œ ë´¤ë˜ ê³µì‹ì— ë”°ë¼ ì •í•´ì§„ë‹¤.

line 16

* ì§€ê¸ˆ ëˆì„ ë„£ì€ ì‚¬ëŒ(to ì£¼ì†Œ)ì—ê²Œ liquidity(LP token)ì„ ì¤€ë‹¤.

line 18 - 19

* ê°’ë“¤ì„ ì—…ë°ì´íŠ¸ í•´ì¤€ë‹¤.

line 20

* ë¯¼íŠ¸í–ˆë‹¤ê³  ë¡œê·¸ë¥¼ ë‚¨ê¸´ë‹¤.

### burn

```solidity
// this low-level function should be called from a contract which performs important safety checks
function burn(address to) external lock returns (uint amount0, uint amount1) {
    (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings
    address _token0 = token0;                                // gas savings
    address _token1 = token1;                                // gas savings
    uint balance0 = IERC20(_token0).balanceOf(address(this));
    uint balance1 = IERC20(_token1).balanceOf(address(this));
    uint liquidity = balanceOf[address(this)];

    bool feeOn = _mintFee(_reserve0, _reserve1);
    uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee
    amount0 = liquidity.mul(balance0) / _totalSupply; // using balances ensures pro-rata distribution
    amount1 = liquidity.mul(balance1) / _totalSupply; // using balances ensures pro-rata distribution
    require(amount0 > 0 && amount1 > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_BURNED');
    _burn(address(this), liquidity);
    _safeTransfer(_token0, to, amount0);
    _safeTransfer(_token1, to, amount1);
    balance0 = IERC20(_token0).balanceOf(address(this));
    balance1 = IERC20(_token1).balanceOf(address(this));

    _update(balance0, balance1, _reserve0, _reserve1);
    if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date
    emit Burn(msg.sender, amount0, amount1, to);
}
```

line 1 - 6

* mintì™€ ë§ˆì°¬ê°€ì§€ë¡œ ì”ê³  ì •ë³´ë¥¼ ê°€ì ¸ì˜¨ë‹¤.

line 10 - 11

* ì´ ì‚¬ëŒì´ ì§€ê¸ˆ íƒœìš°ëŠ” liquidityì˜ ë¹„ìœ¨ì— í•´ë‹¹í•˜ëŠ” ê° í† í°ì˜ amount ë§Œí¼ì„ íƒœìš°ëŠ” ì‚¬ëŒì´ ë°›ê²Œ ëœë‹¤.

line 14 - 15

* LP tokenì„ ì „ì†¡í•´ì¤€ë‹¤.

line 16 - 20

* ë³€ê²½ëœ ê°’ë“¤ì´ ì—…ë°ì´íŠ¸ ëœë‹¤.

### swap

```solidity
// this low-level function should be called from a contract which performs important safety checks
function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external lock {
    require(amount0Out > 0 || amount1Out > 0, 'UniswapV2: INSUFFICIENT_OUTPUT_AMOUNT');
    (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings
    require(amount0Out < _reserve0 && amount1Out < _reserve1, 'UniswapV2: INSUFFICIENT_LIQUIDITY');

    uint balance0;
    uint balance1;
    { // scope for _token{0,1}, avoids stack too deep errors
    address _token0 = token0;
    address _token1 = token1;
    require(to != _token0 && to != _token1, 'UniswapV2: INVALID_TO');
    if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens
    if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens
    if (data.length > 0) IUniswapV2Callee(to).uniswapV2Call(msg.sender, amount0Out, amount1Out, data);
    balance0 = IERC20(_token0).balanceOf(address(this));
    balance1 = IERC20(_token1).balanceOf(address(this));
    }
    uint amount0In = balance0 > _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0;
    uint amount1In = balance1 > _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0;
    require(amount0In > 0 || amount1In > 0, 'UniswapV2: INSUFFICIENT_INPUT_AMOUNT');
    { // scope for reserve{0,1}Adjusted, avoids stack too deep errors
    uint balance0Adjusted = balance0.mul(1000).sub(amount0In.mul(3));
    uint balance1Adjusted = balance1.mul(1000).sub(amount1In.mul(3));
    require(balance0Adjusted.mul(balance1Adjusted) >= uint(_reserve0).mul(_reserve1).mul(1000**2), 'UniswapV2: K');
    }

    _update(balance0, balance1, _reserve0, _reserve1);
    emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);
}
```

ë‘ í† í°ì„ êµí™˜í•˜ëŠ” í•¨ìˆ˜ì´ë‹¤.

ë³´í†µ êµí™˜ì„ ìƒê°í•˜ë©´ ì§€ë¶ˆí•˜ëŠ” í† í°ê³¼ ë°›ëŠ” í† í°ì´ ìˆìœ¼ë©´ ëœë‹¤ê³  ìƒê°í•˜ëŠ”ë° ì´ í•¨ìˆ˜ëŠ” ë„£ëŠ” ëˆ(in)ì€ ì—†ê³  outë§Œ 2ê°œê°€ ìˆë‹¤.

flash loanì´ë¼ê³  í•´ì„œ ì•”í˜¸í™”í ëŒ€ì¶œ ì„œë¹„ìŠ¤ì¸ Aaveë‚˜ Compoundì—ì„œ í† í°ì„ ë¨¼ì € ë¹Œë¦° ë‹¤ìŒì— ê·¸ í† í°ì„ swapí•˜ê³  swapí•œ í† í°ì„ ë‹¤ë¥¸ ê³³ì— ì§‘ì–´ ë„£ì–´ ê°€ì§€ê³  ì°¨ì•¡ì„ ì–»ì€ ë‹¤ìŒ ë‹¤ì‹œ Aaveë‚˜ Compoundì— ë°˜ë‚©í•˜ëŠ” ê·¸ëŸ° ì‹ì˜ ì‘ì—…ì„ í•œ íŠ¸ëœì­ì…˜ ë‚´ì—ì„œ atomicí•˜ê²Œ ìˆ˜í–‰í•˜ëŠ” ê²½ìš°ê°€ ìˆë‹¤.

Uniswapì—ì„œë„ flash loanì„ ì“¸ ìˆ˜ ìˆë„ë¡ êµ¬í˜„í•´ë†“ì€ ê²ƒì´ë‹¤.

inì€ ì´ ìŠ¤ì™‘í•¨ìˆ˜ë¥¼ ì‹¤í–‰ì‹œí‚¤ê¸° ì „ì— pair ì»¨íŠ¸ë™íŠ¸ì˜ token ì£¼ì†Œë¡œ ë¨¼ì € êµí™˜í•˜ê³ ì í•˜ëŠ” í† í°ì„ ì§‘ì–´ë„£ì–´ì•¼ í•œë‹¤. ê·¸ í›„ì— ì´ swap í•¨ìˆ˜ë¥¼ ë¶€ë¥¸ë‹¤.

ë°±ì„œìƒìœ¼ë¡œ ë³´ë©´ inì— í•´ë‹¹í•˜ëŠ” argumentê°€ ì—†ìœ¼ë‹ˆê¹Œ ëˆì„ ëˆ„ê°€ ì–¼ë§ˆë‚˜ ë³´ëƒˆëŠ”ì§€ë¥¼ ì•Œê¸° í˜ë“¤ì–´ì„œ í”„ë¼ì´ë²„ì‹œë¥¼ ì§€í‚¬ ìˆ˜ ìˆë‹¤ê³  í•œë‹¤.

line 1 - 10

* ê°’ë“¤ì„ ë°›ì•„ì˜¤ê³  ê²€ì‚¬í•œë‹¤.

line 11 - 12

* í† í°0, 1ì„ amount0, 1ë§Œí¼ ë³´ë‚¸ë‹¤.

line 13

* ë­”ê°€ ë°ì´í„°ê°€ ìˆë‹¤ë©´ UniswapV2Callì´ë¼ëŠ” í•¨ìˆ˜ë¥¼ ì´ìš©í•´ì„œ ì½œ í•´ì¤€ë‹¤.
* Uniswapì„ ì‹¤í–‰í•œ í›„ì— ë‹¤ë¥¸ ë¬´ì–¸ê°€ë¥¼ ì‹¤í–‰í•˜ê²Œ ë§Œë“¤ ìˆ˜ê°€ ìˆë‹¤. ê·¸ëŸ´ ë•Œ ì € ë°ì´í„°ì— ê°’ì„ ë„£ì–´ì„œ ì´ í•¨ìˆ˜ë¡œ ë¶€ë¥¼ ìˆ˜ê°€ ìˆë‹¤.
* ì˜ˆë¥¼ ë“¤ë©´ Aaveë‚˜ Compoundì— ëŒ€ì¶œì„ ìƒí™˜í•˜ëŠ” ì½”ë“œê°€ ë  ìˆ˜ ìˆë‹¤.

line 14 - 15

* ì´ ì‚¬ëŒì´ ëˆì„ ë„£ì—ˆëŠ”ì§€ í™•ì¸í•˜ê¸° ìœ„í•´ balanceë¥¼ ë°›ì•„ì˜¨ë‹¤.

line 17 - 18

* inì„ ê³„ì‚°í•œë‹¤.
* ìƒˆë¡œìš´ balanceë³´ë‹¤ ì›ë˜ ê°€ì§€ê³  ìˆë˜ reserveì—ì„œ ë‚´ê°€ ë‹¤ë¥¸ë° ë³´ë‚¸ ëˆ(amountOut)ì„ ëº€ ê²ƒì´ ì‘ìœ¼ë©´ balanceë¥¼ ì¡°ì •í•´ì¤€ë‹¤.
* ê·¸ ë°˜ëŒ€ì´ë©´ amountê°€ ì˜ëª»ëœ ê²ƒì´ë‹¤. ë³´ë‚¼ ìˆ˜ ìˆëŠ” ì–‘ë³´ë‹¤ ë” í¬ê²Œ ëœ ê²ƒì´ë‹¤. ê·¸ëŸ° ê²½ìš° 0ì„ ëŒ€ì…í•œë‹¤.

line 19

* amountInì´ ë‘˜ ì¤‘ í•˜ë‚˜ë¼ë„ 0ì´ë©´ â€˜ì…ê¸ˆì•¡ì´ ë¶€ì¡±í•¨â€™ì´ë¼ê³  í•´ì„œ ì·¨ì†Œëœë‹¤.

line 21 - 22

* balanceë¥¼ ì¡°ì •í•œë‹¤.

line 23

* 0.3% ìˆ˜ìˆ˜ë£Œë¥¼ ë‚¼ ìˆ˜ ìˆëŠ”ì§€ í™•ì¸í•œë‹¤.

### skim

```solidity
// force balances to match reserves
function skim(address to) external lock {
    address _token0 = token0; // gas savings
    address _token1 = token1; // gas savings
    _safeTransfer(_token0, to, IERC20(_token0).balanceOf(address(this)).sub(reserve0));
    _safeTransfer(_token1, to, IERC20(_token1).balanceOf(address(this)).sub(reserve1));
}
```

ë§Œì•½ ì…ê¸ˆëœ í† í°ì´ ì´ pair ì»¨íŠ¸ë™íŠ¸ì—ì„œ ë‹´ì„ ìˆ˜ ìˆëŠ” í† í°ì˜ ì–‘ì„ ë„˜ì—ˆì„ ë•Œ ë‚¨ëŠ” ì—¬ìœ ë¶„ì„ íšŒìˆ˜í•  ìˆ˜ ìˆê²Œ ë§Œë“¤ì–´ì£¼ëŠ” í•¨ìˆ˜ì´ë‹¤.

íšŒìˆ˜ë¥¼ í•˜ì§€ ì•Šìœ¼ë©´ Kê°’ì´ maxë¡œ ê³ ì •ë˜ì–´ ìˆìœ¼ë‹ˆê¹Œ ë¡œì§ì´ ë§ê°€ì§„ë‹¤.

### sync

```solidity
// force reserves to match balances
function sync() external lock {
    _update(IERC20(token0).balanceOf(address(this)), IERC20(token1).balanceOf(address(this)), reserve0, reserve1);
}
```

skimê³¼ ë°˜ëŒ€ë¡œ ëˆì´ ë„ˆë¬´ ì ì€ë° í† í°ê°„ì— imbalanceê°€ ìƒê²¼ì„ ë•Œ ê·¸ê²ƒì„ ë‹¤ì‹œ ë§ì¶°ì£¼ê¸° ìœ„í•´ì„œ ë¶€ë¥´ëŠ” í•¨ìˆ˜ì´ë‹¤.

## Router

Uniswapì€ pairë¡œ í† í° í’€ì„ ë§Œë“¤ê³  ë§Œì•½ì— êµí™˜í•˜ê³  ì‹¶ì€ í† í°ì´ ìˆìœ¼ë©´ ê·¸ í’€ì´ ìˆì–´ì•¼ ëœë‹¤. ê·¸ë˜ì„œ Uniswapì—ëŠ” ê·¸ í’€ì˜ ì–‘ì´ êµ‰ì¥íˆ ë§ì„ ê²ƒì´ë‹¤. ê·¸ ëª¨ë“  í’€ì„ ë§Œë“œëŠ” ê²ƒì€ êµ‰ì¥íˆ ë¹„íš¨ìœ¨ì ì´ë‹¤.

í˜ì–´ê°€ ë§Œì•½ ì¡´ì¬í•˜ì§€ ì•Šìœ¼ë©´ ì§ì ‘ì ì¸ pairê°€ ì—†ë‹¤ê³  í•˜ë”ë¼ë„ ê·¸ pairë¥¼ ë§Œë“¤ì–´ ë‚¼ ìˆ˜ ìˆëŠ” ë£¨íŠ¸ë¥¼ ì°¾ëŠ”ë‹¤. ê·¸ê²ƒì„ routingì´ë¼ê³  í•œë‹¤.

ì˜ˆë¥¼ ë“¤ì–´ SUSHIì™€ YFI í† í°ì„ êµí™˜í•˜ê³  ì‹¶ì€ë° SUSHI-YFI pair ì»¨íŠ¸ë™íŠ¸ê°€ ì—†ë‹¤ë©´ ë‹¤ë¥¸ê²ƒì„ ì‚¬ìš©í•œë‹¤. SUSHI-WETH pairì™€ WETH-YFI pairë¥¼ ì´ìš©í•˜ì—¬ atomicí•˜ê²Œ SUSHI â†’ WETH â†’ YFI ë¡œ êµí™˜í•œë‹¤.

ìˆ˜ìˆ˜ë£ŒëŠ” ì¡°ê¸ˆ ë” ë‚´ê² ì§€ë§Œ ë¹ ë¥´ê²Œ êµí™˜í•  ìˆ˜ ìˆë‹¤.

![](<../../.gitbook/assets/Untitled (13).png>)

## Reference

[https://www.youtube.com/watch?v=JfLB3DRwz0I\&t=2s](https://www.youtube.com/watch?v=JfLB3DRwz0I\&t=2s)

[GitHub - Uniswap/v2-core: ğŸ› Core smart contracts of Uniswap V2](https://github.com/Uniswap/v2-core)

[íƒˆì¤‘ì•™ ê¸ˆìœµì—ì„œ í”Œë˜ì‹œ ë¡ ì´ë€ ë¬´ì—‡ì¸ê°€ìš”? | Binance Academy](https://academy.binance.com/ko/articles/what-are-flash-loans-in-defi)

[í”Œë˜ì‹œ ë¡  ê³µê²© (Flash Loan Attack)ì›ë¦¬ ë° ë°©ë²• ë¶„ì„](https://medium.com/iotrustlab/%ED%94%8C%EB%9E%98%EC%8B%9C-%EB%A1%A0-%EA%B3%B5%EA%B2%A9-flash-loan-attack-%EC%9B%90%EB%A6%AC-%EB%B0%8F-%EB%B0%A9%EB%B2%95-%EB%B6%84%EC%84%9D-94e01fe1a9c8)
